% Part: cheat-sheets
% Chapter: free-logic
% Section: introduction

\documentclass[../../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{chs}{fre}{sem}

\olsection{Semantics}

Free logic allows \emph{empty constants}, i.e. constant that do not refer to 
any object in the domain of the quantifiers. This is required 
to ensure that:
$$\lexists[v][c=v]$$ isn't a logical truth for every constant $c$ (as
happens in first order logic).

\subsection{Semantics for Negative Free Logic}

Call this Negative Semantics. In Negative semantics empty constants
don't denote anything. $\Value{c}{M}$ is undefined when $c$ is empty.
The clauses for \emph{atomic} and \emph{identity} !!{formula}s are
changed accordingly to require that their terms are defined. The
clauses for quantifiers aren't changed, but we'll see that the
deduction rules for quantifiers must change. For
$\lforall[v][\Obj{F}v]\lif \Obj{F}a$ isn't valid as it is in first
order logic. 


\begin{defn}[!!^{structure}s]
    In the negative system of free logic, $\Log NFL$,
    \article{structure} \emph{!!{structure}}~$\Struct M$ for a language
    $\Lang L_{\Log{FL}}$ of free logic consists of:
    \begin{enumerate}
    \item \emph{Domain:} a set, $\Domain M$,
    \item \emph{Interpretation of !!{constant}s:} for any !!{constant}~$c$ of
      $\Lang L_{\Log{FL}}$, its interpretation $\Assign{c}{M}$ is !!a{element} of 
      $\Domain M$ or undefined,
    \item \emph{Interpretation of !!{predicate}s:} for each $n$-place
      !!{predicate}~$R$ of $\Lang L_{\Log{FL}}$ (other than $\eq$), an $n$-place
      relation $\Assign{R}{M} \subseteq \Domain{M}^n$
    \tagitem{fnTerms}{\item \emph{Interpretation of !!{function}s:} for each $n$-place
      !!{function}~$f$ of $\Lang L_{\Log{FL}}$, an $n$-place function $\Assign{f}{M}
      \colon \Domain{M}^n \to \Domain{M}$}{}
    \end{enumerate}
    The system of negative free logic is \emph{inclusive} if $\Domain M$ is
    allowed to be empty. There is only one such !!{structure}, for interpretations
    can only be defined one way when the domain is empty. We call it the 
    \emph{empty !!{structure}}.
\end{defn}

\begin{defn}[Variable Assignment]
    A \emph{variable assignment}~$s$ for a !!{structure}~$\Struct{M}$ is a
    \emph{partial} function from the set of variables to
    $\Domain M$: for any !!{variable}~$x$ of
    $\Lang L_{\Log{FL}}$, $s(x) \in \Domain M$ or $s(x)$ is undefined. 
    In addition, we stipulate
    an \emph{empty variable assignement} $s^{*}$ that doesn't assign any value to
    any variable.
\end{defn}

\begin{defn}[!!^{value} of Terms]
    If $t$ is a term of the language~$\Lang L_{\Log{FL}}$, $\Struct M$ is a
    !!{structure} for~$\Lang L_{\Log{FL}}$, and $s$ is a !!{variable} assignment
    for~$\Struct M$, the \emph{!!{value}}~$\Value{t}{M}[s]$ is defined as
    follows:
    \begin{enumerate}
    \item \indcase{t}{c}{$\Value{\indfrm}{M}[s] = \Assign{\indcomplex}{M}$, if defined.}
    \item \indcase{t}{x}{$\Value{\indfrm}{M}[s] = s(\indcomplex)$, if defined.}
    \tagitem{fnTerms}{\indcase{t}{\Atom{f}{t_1, \ldots, t_n}}{
    \[
    \Value{\indfrm}{M}[s] = \Assign{f}{M}(\Value{t_1}{M}[s], \ldots,
    \Value{t_n}{M}[s])\textrm{, if defined}.
    \]}
    }{}
    \end{enumerate}
\end{defn}

We need to allow undefined assignments to ensure that we have 
assignments even in !!{structure}s with an empty domain.

\begin{defn}[Assignement variants]
  If $s$ is a !!{variable} assignment for a !!{structure}~$\Struct M$,
  and $o$ an object in $\Domain M$, and $v$ any variable, the
  \emph{assignment variant} $s(o/v)$ is the assignement that assigns $o$
  to $s$ and agrees with $s$ on every other variable. That is, for any
  variable $u$:
  $$
  s(o/v)(u)=\begin{cases}
    o & \text{if $u$ is $v$},\\
    s(u) & \text{if $u$ is not $v$ and $s(u)$ is defined},\\
    \text{undefined} & \text{otherwise}.  
  \end{cases}
  $$
  We call $s(o/v)$ a \emph{$v$-variant} of $s$.
\end{defn}  

Note that while assignments in general needn't defined for a given
variable, the assignement variant $s(o/x)$ \emph{must} be defined for
the variable $x$ at least, since $s(o/x)=o$. This is what ultimately
ensures that our quantifiers range over existing objects.
        
\begin{defn}[Satisfaction]
    \ollabel{defn:satisfaction}
    Satisfaction of a !!{formula}~$!A$ in a !!{structure}~$\Struct M$
    relative to a !!{variable} assignment~$s$, in symbols:
    $\Sat{M}{!A}[s]$, is defined recursively as follows. (We write
    $\Sat/{M}{!A}[s]$ to mean ``not $\Sat{M}{!A}[s]$.'')
    \begin{enumerate}
    \tagitem{prvFalse}{%
      \indcase{!A}{\lfalse}{$\Sat/{M}{\indfrm}[s]$.}}{}
    
    \tagitem{prvTrue}{%
      \indcase{!A}{\ltrue}{$\Sat{M}{\indfrm}[s]$.}}{}
    
    \item \indcase{!A}{\Atom{R}{t_1, \dots, t_n}}{$\Sat{M}{\indfrm}[s]$
      iff $\Value{t_i}{M}[s]$ is defined for any $1\leq i \leq n$ and 
      $\langle \Value{t_1}{M}[s], \dots, \Value{t_n}{M}[s] \rangle \in
      \Assign{R}{M}$.}
    
    \item \indcase{!A}{\Atom{\lfrexists}{t}}{$\Sat{M}{\indfrm}[s]$ iff 
      $\Value{t}{M}[s]$ is defined.}
    
    \item \indcase{!A}{\eq[t_1][t_2]}{$\Sat{M}{\indfrm}[s]$ iff 
      $\Value{t_1}{M}[s], \Value{t_2}{M}[s]$ are both defined and
      $\Value{t_1}{M}[s] = \Value{t_2}{M}[s]$.}
    
    \tagitem{prvNot}{%
      \indcase{!A}{\lnot !B}{$\Sat{M}{\indfrm}[s]$ iff
        $\Sat/{M}{!B}[s]$.}}{}
    
    \tagitem{prvAnd}{%
      \indcase{!A}{(!B \land !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat{M}{!B}[s]$
        and $\Sat{M}{!C}[s]$.}}{}
    
    \tagitem{prvOr}{%
      \indcase{!A}{(!B \lor !C)}{$\Sat{M}{\indfrm}[s]$ iff
        $\Sat{M}{!A}[s]$ or $\Sat{M}{!B}[s]$ (or both).}}{}
    
    \tagitem{prvIf}{%
      \indcase{!A}{(!B \lif !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat/{M}{!B}[s]$
        or $\Sat{M}{!C}[s]$ (or both).}}{}
    
    \tagitem{prvIff}{%
      \indcase{!A}{(!B \liff !C)}{$\Sat{M}{\indfrm}[s]$ iff either both
        $\Sat{M}{!B}[s]$ and $\Sat{M}{!C}[s]$, or neither $\Sat{M}{!B}[s]$
        nor $\Sat{M}{!C}[s]$.}}{}
    
    \tagitem{prvAll}{%
      \indcase{!A}{\lforall[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff for every
      object $o\in \Domain M$, $\Sat{M}{!B}[s(o/x)]$.}}{}
  
    \tagitem{prvEx}{%
      \indcase{!A}{\lexists[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff iff for some
      object $o\in \Domain M$, $\Sat{M}{!B}[s(o/x)]$.}}{}
    \end{enumerate}
\end{defn}
    
Truth and validity are defined as in first-order logic.
    
\begin{defn}[Truth]
Where $!A$ is a closed !!{formula}, we say that $A$ is \emph{true in}, or
\emph{satisfied by} a !!{structure} $\Struct M$, written $\Sat{M}{!A}$ iff 
$A$ is satisfied relative to any assignement in $\Struct M$:
$$\Sat{M}{!A}\textrm{ iff }\Sat{M}{!A}[s]\textrm{ for any }s\textrm{ in }\Struct M$$
\end{defn}

\begin{defn}[Validity]
    A !!{formula} $!A$ is \emph{valid}, $\Entails !A$, iff $\Sat{M}{!A}$ for every
    !!{structure}~$\Struct M$.
\end{defn}

\subsection{Semantics for Positive Free Logic}

Call these Positive Semantics. In Positive Semantics empty terms are 
assigned a referent but this referent is deemed 'non-existing'. 
We have two domains: the \emph{inner} domain over which quantifiers
range, and the \emph{outer} domain that includes, but is not restricted
to, the inner domain. Empty names are assigned to objects outside the 
inner domain. 

Positive semantics raise questions of interpretation: what are these
objects outside the inner domain? Do we take them seriously? If we 
don't, what is the real meaning of empty names? But you must first 
understand the semantics mechanics, leaving the philosophical questions 
aside. 

Predicates are allowed to take values from the outer domain. Thus
$\Obj{P}a$ or $\Obj{G}ab$ may be true in a !!{structure} even if $a$,
$a,b$ are empty names. Identity claims $\eq[c][d]$ are substantial
even if $c$, $d$ are empty, for they may or may not be true. 

Quantifiers only range over the inner domain, however. This is ensured
by restricting variable assignments to objects in the \emph{inner}
domain.

\begin{defn}[!!^{structure}s]
    In the positive system of free logic, $\Log NFL$,
    \article{structure} \emph{!!{structure}}~$\Struct M$ for a language
    $\Lang L_{\Log{FL}}$ of free logic consists of:
    \begin{enumerate}
    \item \emph{(Inner) Domain:} a set, $\Domain M$,
    \item \emph{Outer Domain:} a non-empty set, $\OuterDomain M$ that
        includes $\Domain M$ ($\Domain M \subseteq \OuterDomain M $),
    \item \emph{Interpretation of !!{constant}s:} for any !!{constant}~$c$ of
      $\Lang L_{\Log{FL}}$, its interpretation $\Assign{c}{M}$ is !!a{element} of 
      $\OuterDomain M$,
    \item \emph{Interpretation of !!{predicate}s:} for each $n$-place
      !!{predicate}~$R$ of $\Lang L_{\Log{FL}}$ (other than $\eq$), an $n$-place
      relation $\Assign{R}{M} \subseteq \OuterDomain M^n$
    \tagitem{fnTerms}{\item \emph{Interpretation of !!{function}s:} for each $n$-place
      !!{function}~$f$ of $\Lang L_{\Log{FL}}$, an $n$-place function $\Assign{f}{M}
      \colon \OuterDomain M^n \to \OuterDomain M$.}{}
    \end{enumerate}
    The system of positive free logic is \emph{inclusive} if $\Domain M$ is
    allowed to be empty. There are several such !!{structure}s, as they may
    still differ on the !!{element}s of $\OuterDomain M$ outside of $M$ and the 
    interpretations of constants and predicates. We call a !!{structure} with
    empty $\Domain M$ an \emph{empty structure}. 
\end{defn}
    
\begin{defn}[Variable Assignment]
  A \emph{variable assignment}~$s$ for a !!{structure}~$\Struct{M}$ is a
    function such that for any !!{variable}~$x$ of
    $\Lang L_{\Log{FL}}$, $s(x) \in \OuterDomain M$. 
\end{defn}

In this semantics, assignements are defined for all variables: 
$s(x)$ is always defined. In !!{structure}s with empty \emph{inner}
domain, we have at least one object in the outer domain to which 
variables can be assigned. 

\begin{defn}[!!^{value} of Terms]
  If $t$ is a term of the language~$\Lang L_{\Log{FL}}$, $\Struct M$ is a
  !!{structure} for~$\Lang L_{\Log{FL}}$, and $s$ is a !!{variable} assignment
  for~$\Struct M$, the \emph{!!{value}}~$\Value{t}{M}[s]$ is defined as
  follows:
  \begin{enumerate}
  \item \indcase{t}{c}{$\Value{\indfrm}{M}[s] = \Assign{\indcomplex}{M}$.}
  \item \indcase{t}{x}{$\Value{\indfrm}{M}[s] = s(\indcomplex)$.}
  \tagitem{fnTerms}{\indcase{t}{\Atom{f}{t_1, \ldots, t_n}}{
  \[
  \Value{\indfrm}{M}[s] = \Assign{f}{M}(\Value{t_1}{M}[s], \ldots,
  \Value{t_n}{M}[s])\textrm{, if defined}.
  \]}
  }{}
  \end{enumerate}
\end{defn}
      

\begin{defn}[Assignement variants]
  If $s$ is a !!{variable} assignment for a !!{structure}~$\Struct M$,
  and $o$ an object in the \emph{inner} $\Domain M$, and $v$ any variable, the
  \emph{assignment variant} $s(o/v)$ is the assignement that assigns $o$
  to $s$ and agrees with $s$ on every other variable. That is, for any
  variable $u$:
  $$
  s(o/v)(u)=\begin{cases}
    o & \text{if $u$ is $v$},\\
    s(u) & \text{otherwise}.  
  \end{cases}
  $$
  We call $s(o/v)$ a \emph{$v$-variant} of $s$.
\end{defn}

Note that while an assignment $s$ can assign any object in the outer 
domain to $x$, the assignement variants $s(o/x)$ only assign
\emph{inner} domain objects to $x$. This will ensure that our 
quantifiers only range over the \emph{inner} domain. 

If $\Struct M$ has an empty domain, it still has assignments $s$, as we 
noted above. But there are no $x$-variants of $s$, since there is 
no inner domain object to assign to $s$. This
has the desired result that in that !!{structure},
$\lforall[x][!A]$ !!{formula}s are all trivially true and
$\lexists[x][!A]$ all trivially false. 

\begin{defn}[Satisfaction]
    \ollabel{defn:satisfaction}
    Satisfaction of a !!{formula}~$!A$ in a !!{structure}~$\Struct M$
    relative to a !!{variable} assignment~$s$, in symbols:
    $\Sat{M}{!A}[s]$, is defined recursively as follows. (We write
    $\Sat/{M}{!A}[s]$ to mean ``not $\Sat{M}{!A}[s]$.'')
    \begin{enumerate}
    \tagitem{prvFalse}{%
      \indcase{!A}{\lfalse}{$\Sat/{M}{\indfrm}[s]$.}}{}
    
    \tagitem{prvTrue}{%
      \indcase{!A}{\ltrue}{$\Sat{M}{\indfrm}[s]$.}}{}
    
    \item \indcase{!A}{\Atom{R}{t_1, \dots, t_n}}{$\Sat{M}{\indfrm}[s]$
      iff $\langle \Value{t_1}{M}[s], \dots, \Value{t_n}{M}[s] \rangle \in
      \Assign{R}{M}$.}
    
    \item \indcase{!A}{\Atom{\lfrexists}{t}}{$\Sat{M}{\indfrm}[s]$ iff 
      $\Value{t}{M}[s] \in \Domain M$.}
    
    \item \indcase{!A}{\eq[t_1][t_2]}{$\Sat{M}{\indfrm}[s]$ iff 
      $\Value{t_1}{M}[s] = \Value{t_2}{M}[s]$.}
    
    \tagitem{prvNot}{%
      \indcase{!A}{\lnot !B}{$\Sat{M}{\indfrm}[s]$ iff
        $\Sat/{M}{!B}[s]$.}}{}
    
    \tagitem{prvAnd}{%
      \indcase{!A}{(!B \land !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat{M}{!B}[s]$
        and $\Sat{M}{!C}[s]$.}}{}
    
    \tagitem{prvOr}{%
      \indcase{!A}{(!B \lor !C)}{$\Sat{M}{\indfrm}[s]$ iff
        $\Sat{M}{!A}[s]$ or $\Sat{M}{!B}[s]$ (or both).}}{}
    
    \tagitem{prvIf}{%
      \indcase{!A}{(!B \lif !C)}{$\Sat{M}{\indfrm}[s]$ iff $\Sat/{M}{!B}[s]$
        or $\Sat{M}{!C}[s]$ (or both).}}{}
    
    \tagitem{prvIff}{%
      \indcase{!A}{(!B \liff !C)}{$\Sat{M}{\indfrm}[s]$ iff either both
        $\Sat{M}{!B}[s]$ and $\Sat{M}{!C}[s]$, or neither $\Sat{M}{!B}[s]$
        nor $\Sat{M}{!C}[s]$.}}{}
    

    \tagitem{prvAll}{%
        \indcase{!A}{\lforall[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff for every 
        object $o$ in the \emph{inner} domain $\Domain M$, 
        $\Sat{M}{!B}[s(o/x)]$.}}{}
      
    \tagitem{prvEx}{%
        \indcase{!A}{\lexists[x][!B]}{$\Sat{M}{\indfrm}[s]$ iff for some 
        object $o$ in the \emph{inner} domain $\Domain M$, 
        $\Sat{M}{!B}[s(o/x)]$}}{}
    \end{enumerate}
\end{defn}
    
Truth and validity are defined as usual.

\end{document}