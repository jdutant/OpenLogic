% Part: first-order-logic
% Chapter: syntax-and-semantics
% Section: first-order-languages

\documentclass[../../../include/open-logic-section]{subfiles}

\begin{document}

\olfileid{frl}{syn}{lfr}

\olsection{Language of Free Logic}

The language of free logic is a first-order language supplemented with a 
one-place ``existence'' predicate, $\lfrexists$.

In systems of free logic that are bivalent and with !!{identity}, the 
existence predicate can be defined by:

\begin{defn}[Existence predicate]
$\Atom{\lfrexists}{t}$ abbreviates $\lexists x (\eq[t][x])$
\end{defn}

In neutral (non-bivalent) systems, or in languages without !!{identity}, 
$\lfrexists$ must be introduced as a primitive instead.

The following is a rigorous definition of the language of free logic. It mostly
repeats the language of first-order logic, with additions for a 
primitive $\lfrexists$ predicate.

We will thus make use of the following symbols in the language of 
free logic: 

\begin{enumerate}
\item Logical symbols
\begin{enumerate}
\item Logical connectives:
  \startycommalist
  \iftag{prvNot}{\ycomma $\lnot$ (negation)}{}%
  \iftag{prvAnd}{\ycomma $\land$ (conjunction)}{}%
  \iftag{prvOr}{\ycomma $\lor$ (disjunction)}{}%
  \iftag{prvIf}{\ycomma $\lif$ (!!{conditional})}{}%
  \iftag{prvIff}{\ycomma $\liff$ (!!{biconditional})}{}%
  \iftag{prvAll}{\ycomma $\lforall$ (universal quantifier)}{}%
  \iftag{prvEx}{\ycomma $\lexists$ (existential quantifier)}{}.
\tagitem{prvFalse}{The propositional constant for !!{falsity}~$\lfalse$.}{}
\tagitem{prvTrue}{The propositional constant for !!{truth}~$\ltrue$.}{}
\item The one-place existence predicate~$\lfrexists$.
\item The two-place !!{identity}~$\eq$.
\item A !!{denumerable}s set of !!{variable}s: $\Obj v_0$, $\Obj v_1$, $\Obj
  v_2$, \dots
\end{enumerate}
\item Non-logical symbols, making up the \emph{standard
  language} of first-order logic
\begin{enumerate}
\item A !!{denumerable}s set of $n$-place !!{predicate}s for each $n>0$: $\Obj
  A^n_0$, $\Obj A^n_1$, $\Obj A^n_2$, \dots
\item A !!{denumerable}s set of !!{constant}s: $\Obj c_0$, $\Obj c_1$, $\Obj
  c_2$, \dots.
\tagitem{fnTerms}{A !!{denumerable}s set of $n$-place !!{function}s for each $n>0$:
  $\Obj f^n_0$, $\Obj f^n_1$, $\Obj f^n_2$, \dots}{}
\end{enumerate}
\item Punctuation marks: (, ), and the comma.
\end{enumerate}

\iftag{defNot,defOr,defAnd,defIf,defIff,defTrue,defFalse,defEx,defAll}{%
In addition to the primitive connectives and
\iftag{notprvEx,notprvAll}{quantifier}{quantifiers} introduced
above, we also use the following \emph{defined} symbols:
\startycommalist
  \iftag{defNot}{\ycomma $\lnot$ (negation)}{}%
  \iftag{defAnd}{\ycomma $\land$ (conjunction)}{}%
  \iftag{defOr}{\ycomma $\lor$ (disjunction)}{}%
  \iftag{defIf}{\ycomma $\lif$ (!!{conditional})}{}%
  \iftag{defIff}{\ycomma $\liff$ (!!{biconditional})}{}%
  \iftag{defAll}{\ycomma $\lforall$ (universal quantifier)}{}%
  \iftag{defEx}{\ycomma $\lexists$ (existential quantifier)}{}%
  \iftag{defFalse}{\ycomma !!{falsity}~$\lfalse$}{}%
  \iftag{defTrue}{\ycomma !!{truth}~$\ltrue$}.}{}

The language $\Lang L_{\Log{FL}}$ of free logic is defined as follows.

\begin{defn}[Terms]
\ollabel{defn:terms}
The set of \emph{terms}~$\Trm[L_{\Log{FL}}]$ of~$\Lang L_{\Log{FL}}$ is
defined\iftag{fnTerms}{ inductively}{} by:
\begin{enumerate}
\item Every !!{variable} is a term.
\item Every !!{constant} of~$\Lang L_{\Log{FL}}$ is a term.
\tagitem{fnTerms}{ If $f$ is an $n$-place !!{function} and $t_1$, \dots, $t_n$
  are terms, then $\Atom{f}{t_1, \ldots, t_n}$ is a term.}{}
\tagitem{limitClause}{
  Nothing else is a term.}{}
\end{enumerate}
\iftag{fnTerms}{
  A term containing no !!{variable}s is a \emph{closed term}.
}{
  A constant is a \emph{closed term}.
}
\end{defn}


\begin{defn}[Formula]
\ollabel{defn:formulas}
The set of \emph{!!{formula}s}~$\Frm[L_{\Log{FL}}]$ of the language~$\Lang L_{\Log{FL}}$
is defined inductively as follows:
\begin{enumerate}
\tagitem{prvFalse}{$\lfalse$ is an atomic !!{formula}.}{}

\tagitem{prvTrue}{$\ltrue$ is an atomic !!{formula}.}{}

\item If $R$ is an $n$-place !!{predicate} of~$\Lang L_{\Log{FL}}$ and $t_1$, \dots,
  $t_n$ are terms of~$\Lang L_{\Log{FL}}$, then $\Atom{R}{t_1,\ldots, t_n}$ is an
  atomic !!{formula}.

\item If $t$ is a term of~$\Lang L_{\Log{FL}}$, then $\Atom{\lfrexists}{t}$
  is an atomic !!{formula}.

\item If $t_1$ and $t_2$ are terms of~$\Lang L_{\Log{FL}}$, then $\Atom{\eq}{t_1, t_2}$
  is an atomic !!{formula}.

\tagitem{prvNot}{If $!A$ is a !!{formula}, then $\lnot !A$ is
  !!{formula}.}{}

\tagitem{prvAnd}{If $!A$ and $!B$ are !!{formula}s, then $(!A \land
  !B)$ is a !!{formula}.}{}

\tagitem{prvOr}{If $!A$ and $!B$ are !!{formula}s, then $(!A \lor !B)$
  is a !!{formula}.}{}

\tagitem{prvIf}{If $!A$ and $!B$ are !!{formula}s, then $(!A \lif !B)$
  is a !!{formula}.}{}

\tagitem{prvIff}{If $!A$ and $!B$ are !!{formula}s, then $(!A \liff !B)$
  is a !!{formula}.}{}

\tagitem{prvAll}{If $!A$ is a !!{formula} and $x$ is a !!{variable},
  then $\lforall[x][!A]$ is a !!{formula}.}{}

\tagitem{prvEx}{If $!A$ is a !!{formula} and $x$ is a !!{variable},
  then $\lexists[x][!A]$ is a !!{formula}.}{}

\tagitem{limitClause}{Nothing else is a !!{formula}.}{}
\end{enumerate}
\end{defn}

By convention, we write $\eq$ between its arguments and leave out the
parentheses: $\eq[t_1][t_2]$ is an abbreviation for
$\Atom{\eq}{t_1,t_2}$.  Moreover, $\lnot \Atom{\eq}{t_1,t_2}$ is
abbreviated as $\eq/[t_1][t_2]$. When writing a formula $(!B \ast !C)$
constructed from $!B$, $!C$ using a two-place connective~$\ast$, we
will often leave out the outermost pair of parentheses and write
simply~$!B \ast !C$.

\begin{tagblock}{defNot,defOr,defAnd,defIf,defIff,defTrue,defFalse,defEx,defAll}
\begin{defn}
Formulas constructed using the defined operators are to be understood
as follows:

\begin{tagenumerate}{defTrue,defFalse,defNot,defOr,defAnd,defIf,defIff,defEx,defAll}

\tagitem{defTrue}{$\ltrue$ abbreviates
  \iftag{prvFalse}{$\lnot\lfalse$}{$(!A \lor \lnot !A)$ for some
    fixed atomic !!{formula}~$!A$}.}{}

\tagitem{defFalse}{$\lfalse$ abbreviates
  \iftag{prvTrue}{$\lnot\ltrue$}{$(!A \land \lnot !A)$ for some
    fixed atomic !!{formula}~$!A$}.}{}

\tagitem{defNot}{$\lnot !A$ abbreviates $!A \lif \lfalse$.}{}

\tagitem{defOr}{$!A \lor !B$ abbreviates
  \iftag{prvAnd}{$\lnot(\lnot !A \land \lnot !B)$}{$\lnot !A \lif
    !B$}.}{}

\tagitem{defAnd}{$!A \land !B$ abbreviates
  \iftag{prvOr}{$\lnot(\lnot !A \lor \lnot !B)$}{$\lnot (!A \lif
    \lnot !B)$}.}{}

\tagitem{defIf}{$!A \lif !B$ abbreviates
  \iftag{prvOr}{$\lnot !A \lor !B)$}{$\lnot (!A \land \lnot !B)$}.}{}

\tagitem{defIff}{$!A \liff !B$ abbreviates $(!A \lif !B) \land (!B
  \lif !A)$.}{}

\tagitem{defAll}{$\lforall[x][!A]$ abbreviates $\lnot\lexists[x][\lnot !A]$.}{}

\tagitem{defEx}{$\lexists[x][!A]$ abbreviates $\lnot\lforall[x][\lnot !A]$.}{}
\end{tagenumerate}
\end{defn}
\end{tagblock}

If we work in a language for a specific application, we will often
write two-place !!{predicate}s\iftag{fnTerms}{ and !!{function}s}{} between the
respective terms, e.g., $t_1 < t_2$\iftag{fnTerms}{ and $(t_1 + t_2)$}{} in the language
of arithmetic and $t_1 \in t_2$ in the language of set theory. \iftag{fnTerms}{The
successor function in the language of arithmetic is even written
conventionally \emph{after} its argument:~$t'$. }Officially, however,
these are just conventional abbreviations for $\Atom{A^2_0}{t_1, t_2}$,
\iftag{fnTerms}{$\Atom{f^2_0}{t_1, t_2}$, }{and }$\Atom{A^2_0}{t_1, t_2}%
$\iftag{fnTerms}{, and $f^1_0(t)$}{}, respectively.

\begin{defn}[Syntactic identity]
The symbol $\ident$ expresses syntactic identity between strings of
symbols, i.e., $!A \ident !B$ iff $!A$ and $!B$ are strings of symbols
of the same length and which contain the same symbol in each place.
\end{defn}

The $\ident$ symbol may be flanked by strings obtained by
concatenation, e.g., $!A \ident (!B \lor !C)$ means: the string of
symbols~$!A$ is the same string as the one obtained by concatenating
an opening parenthesis, the string $!B$, the $\lor$ symbol, the
string~$!C$, and a closing parenthesis, in this order. If this is the
case, then we know that the first symbol of $!A$ is an opening
parenthesis, $!A$ contains $!B$ as a substring (starting at the second
symbol), that substring is followed by $\lor$, etc.

\end{document}
